% Packages & Document Configurations
\documentclass{report_template}
\usepackage{dirtree}
% Authors & Supervisor
\firstauthor{Andreas Carelius Brustad}

\secondauthor{Håkon Bekken}

\thirdauthor{Johannes Husevåg Standal}

% Report Title & Subtitle
\title{Bay City oil spill simulation}

\subtitle{Course: \textbf{INF202}\\ Project assignment in advanced programming}

% Filiations
\university{Norwegian University of Life Sciences (NMBU)}
\degree{}
\school{}
\course{}

% Local & Date
\date{Norway, \monthname[\month] \number\year}

\begin{document}

% Covers
\include{Covers/00-Cover}

% Roman numeration
\pagenumbering{roman}

% List of contents, figures, and tables
\tableofcontents\blankpage

% Arabic numeration
\pagenumbering{arabic}

% Chapters
\chapter{Introduction}\label{ch:introduction}
Computer simulations are widely used in science and engineering to model complex systems and phenomena. 
They allow researchers to analyze and predict the behavior of systems under various conditions,
providing insights that may be difficult or impossible to obtain through traditional experimental methods.
The problem given of an oil spill has a real world implementation and are of significant for environmental concern. There are multiple examples like the Deepwater Horizon oil spill in 2010, where computational simulations was crucial in order to predict where surface oil would go, aiding skimming, booming, and shoreline protection.
\\
\begin{figure}[H]
\centering
\begin{minipage}{.5\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{Figures/deepwater-horizonbp-oil-spill.jpg}
  \captionof{figure}{Deepwater Horizon oil spill
  \parencite{DeepwaterHorizonOilSpill}}\label{fig:Deepwater Horizon BP oil spill}
\end{minipage}%
\begin{minipage}{.55\textwidth}
  \centering
  \includegraphics[width=.8\linewidth]{Figures/BayCity.png}
  \captionof{figure}{Bay city
  \parencite{Baycity}}\label{fig:Bay city from task}
\end{minipage}
\end{figure}

Our simulation aims to model oil trajectory and spread forecasting in Bay city.
Outside Bay city is a fishing ground that are voulnerable to oil spills.
This report will discuss the mathematical models used to represent the oil spill dynamics,
the numerical methods to solve these models, and the implementation of the simulation.
\newpage

\chapter{Overall problem and solution}

\section{Problem Description}

The fishing town of \emph{Bay City} has reported an oil spill from one of their ships.
The objective of the simulation is to assess the impact of the oil spill on the surrounding
fishing grounds and to determine appropriate measures to protect the local fish population.

An external group of researchers has provided a simplified two-dimensional flow field that is used
to approximate ocean currents in the region. In addition there is provided a two-dimensional map
of Bay City from the file  \texttt{bay.msh}. The data includes the coastline and ocean for the region.

The spatial domain is described using Cartesian coordinates $(x,y)$, where the point
$(0,0)^{\top}$ corresponds to the lower-left corner of the map.

\section{Initialisation}

When a new simulation object is created, a mesh file is loaded from the configuration folder.
The mesh consists of a collection of cells (triangles for the ocean and lines for the coastline). 
Each cell stores a scalar value representing the oil density within
the area of the cell.

The initial oil distribution is centered at the spatial point
\begin{align*}
\vec{x}^{\star} = (x^{\star}, y^{\star})^{\top} &= (0.35, 0.45)^{\top},
\intertext{and is defined by the function}
u(t=0,\vec{x}) &= \exp\left(-\frac{\|\vec{x}-\vec{x}^{\star}\|^{2}}{0.01}\right),
\end{align*}
where $u(t,\vec{x})$ denotes the oil density at position $\vec{x}$ and time $t$.
This formulation produces a localized oil spill with maximum concentration at $\vec{x}^{\star}$
and exponential decay with distance.

The oil density is evaluated at the centerpoint of each cell and stored as the initial oil density value.

\section{Velocity field}

The simplified ocean currents are given by this formula
\[
\vec{v}(\vec{x}, t) =
\begin{pmatrix}
y - 0.2x \\
-x
\end{pmatrix}.
\]
This vector field defines the direction and magnitude of oil flow at each cell. 
The simulation supports parameter for time (t) in order to account for any development in the ocean currents.
If the vectorfield is time-independent this drastically increases the effectiveness of precomputated values. 
Hence giving birth to the optimized faucet simulation. 

\section{Oil transfer}

Oil transport is modeled using a finite-volume formulation on a triangular mesh.
Only triangle cells carry oil; line cells represent boundaries and have identically
zero oil content.

Let $u_i^n$ denote the oil density in triangle cell $i$ at time $t^n$ with area $A_i$.
Let $\vec{\nu}_{i,\ell}$ be the scaled outward normal associated with edge $\ell$ of
cell $i$, and let $\text{ngh}_\ell$ denote the neighboring cell across this edge.
The velocity field is denoted by $\vec{v}(\vec{x},t)$. Note that the scaled normals can be precomputated
for every cell edge before running the simulation. We store this in a dictionary in the cell
using the neighbour object as its key. 

For each edge, the numerical flux contribution is
\[
F_i^{(\text{ngh}_\ell,n)}
=
- \frac{\Delta t}{A_i}
\, g\!\left(
u_i^n,\,
u_{\text{ngh}_\ell}^n,\,
\vec{\nu}_{i,\ell},\,
\vec{v}_{i,\ell}^n
\right),
\]
where the edge velocity is defined as the midpoint average
\[
\vec{v}_{i,\ell}^n
=
\frac{1}{2}
\left(
\vec{v}(\vec{x}_i,t^n)
+
\vec{v}(\vec{x}_{\text{ngh}_\ell},t^n)
\right),
\]
and the upwind flux function $g$ is given by
\[
g(a,b,\vec{\nu},\vec{v}) =
\begin{cases}
a \, \langle \vec{v}, \vec{\nu} \rangle,
& \text{if } \langle \vec{v}, \vec{\nu} \rangle > 0, \\
b \, \langle \vec{v}, \vec{\nu} \rangle,
& \text{else}.
\end{cases}
\]

The oil density update for cell $i$ is then
\[
up_i^{n}
=
\sum_{\ell=1}^{3}
F_i^{(\text{ngh}_\ell,n)}
\]

After every cell has calculated their update value
they will apply it to their own density
\[
u_i^{n+1} = u_i^{n} + up_i^{n}
\]
then the update value will be reset for the next timestep
\[
up_i^{n} = 0
\]

\section{Standard Simulation}

For a time-dependent velocity field $\vec{v}(\vec{x},t)$, the above fluxes are
recomputed at every time step. Given a total simulation time $t_{\text{end}}$ and
$N$ time steps, the time step size is
\[
\Delta t = \frac{t_{\text{end}}}{N}.
\]

At each timestep $t^n = n\Delta t$, fluxes are evaluated for all triangle cells,
and the change in oil densities are stored in a buffer variable. After all the cells has calculated
their update value, they add it to their stored oil density

\section{Faucet Simulation}

When the velocity field is time-independent, its time derivative vanishes,
\[
\frac{\partial \vec{v}}{\partial t} = [0,0],
\]
and the velocity at each cell remains constant for all times.
Consequently, all geometric and kinematic quantities associated with a cell
interface can be precomputed before the simulation starts.

For a triangle cell \(I\) and one of its neighboring cells \(\text{ngh}\),
the edge-averaged velocity is defined as
\[
\vec{v}_{I,\text{ngh}}
= \frac{1}{2}\Big( \vec{v}(\vec{x}_I) + \vec{v}(\vec{x}_{\text{ngh}}) \Big),
\]
which is constant in time.  
The scaled outward normal vector \(\vec{\nu}_{I,\text{ngh}}\) associated with
the common edge is also precomputed and fixed.

The flux direction across the edge is determined by
\[
\langle \vec{v}_{I,\text{ngh}}, \vec{\nu}_{I,\text{ngh}} \rangle.
\]
Only edges for which this quantity is positive are considered, corresponding
to oil flowing out of cell \(I\).

\subsection*{Faucets}

For each such outgoing edge, a \emph{faucet} from cell \(I\) to cell
\(\text{ngh}\) is defined.  
Each faucet is characterized by two constant coefficients,
\[
\text{flow}_{I\to\text{ngh}}
= \frac{\Delta t}{A_I}
\langle \vec{v}_{I,\text{ngh}}, \vec{\nu}_{I,\text{ngh}} \rangle,
\qquad
\text{flow}_{\text{ngh}\to I}
= \frac{\Delta t}{A_{\text{ngh}}}
\langle \vec{v}_{I,\text{ngh}}, \vec{\nu}_{I,\text{ngh}} \rangle,
\]
where \(A_I\) and \(A_{\text{ngh}}\) denote the areas of the source and
neighboring cells, respectively.

These coefficients remain constant throughout the simulation and are
precomputed once during initialization.

\subsection*{Time stepping}

During a single time step, the oil density update induced by one faucet
\((I \rightarrow \text{ngh})\) is given by
\[
u_I^{n+1} = u_I^n - u_I^n\,\text{flow}_{I\to\text{ngh}},
\]
\[
u_{\text{ngh}}^{n+1} = u_{\text{ngh}}^n + u_I^n\,\text{flow}_{\text{ngh}\to I}.
\]

The total update of a cell is obtained by applying all faucets connected to it.
After all faucet contributions have been accumulated, the oil densities of all
cells are updated simultaneously.

\subsection*{Conservation}

This formulation guarantees conservation of the total oil amount.
For each faucet, the oil removed from the source cell is exactly redistributed
to the neighboring cell, with changes scaled by the corresponding cell areas.
Since conservation holds locally for every faucet, it also holds globally over
the entire computational domain.

\chapter{User guide}



\chapter{Code structre}

\section{Folder structre}


\dirtree{%
.1 src.
.2 Geometry.
.3 geometry.py.
.3 mesh.py.
.3 cell.py.
.3 line.py.
.3 triangle.py.
.2 Simulation.
.3 plotter.py.
.3 simulation.py.
.3 solver.py.
.2 InputOutput.  
.3 commandlineParser.py.
.3 log.py.
.3 tomlParser.py.
}


\section{UML-diagram}

\begin{figure}[H]
    \includegraphics[width=1.2\textwidth]{Figures/UML-diagram-final.png}
    \caption{Final UML diagram}
\end{figure}


\chapter{Agile development}
Agile development is an iterative approach to software creation that emphasizes flexibility and
collaboration. The main idea is breaking a complex problem into smaller parts.  
Through small, frequent releases of working software, 
the strategy will produce results that are getting closer and closer to achieve the end goal.

\section{Story map and 3rd party software}
Our approach implementing agile development was firstly to clarify expectations to eachother working in a group.
Secondly, we spent the first days reading and understanding the problem thoroughly. 
By breaking the problem down to smaller pieces, we got a clear idea about what solutions
the problem would require. By identifying this, we structured the work by creating a story map.
\subsection{StoriesOnBoard}
We used a 3rd party software from https://StoriesOnBoard.com with a 14 days free trail in order to facilitate agile development. 
We chose StoriesOnBoard because it offerd more features than native github projects, it had a nice layout, user firendly gui, and the ability to integrate with GitHub. 
Focusing on documentation, organizing the main structre, we achieved a foundtation to start tackeling the problem. 
Applying timelines and sprints, we also gained an idea to when certian taskes was supposed to be done.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{Figures/StoryBoard.png}
    \caption{Story map}
\end{figure}

Our story map follows a traditional setup with Epics at the top, user stories on the second level  and taskes bellow their respective user story.
The tasks were assigned under a Sprint that was set with a duration of 5 days. 
The tasks emphasizes detailed decription and checkmarks within the task, rather then a big quantity of tasks in order to have a clear overview in the Story map.
If a task where missing certain elements, rather then creating new issues or sub issues,
it gave a better overview to edit description and add checkmarks.

\newpage
\begin{figure}[H]
\centering
\begin{minipage}{.45\textwidth}
  \centering
  \includegraphics[width=\linewidth]{Figures/ExampleTask.png}
\end{minipage}\hfill%
\begin{minipage}{.45\textwidth}
  \centering
  \includegraphics[width=\linewidth]{Figures/ExampleTask2.png}
\end{minipage}

\vspace{0.5em}

\begin{minipage}{.65\textwidth}
  \centering
  \includegraphics[width=\linewidth]{Figures/ExampleTask3.png}
\end{minipage}
\caption{Example of tasks}
\end{figure}

Looking at some examples of tasks created on StoriesOnBoard, to demonstrate several features with agile development. 
It has instantanious replication to github issues. The possiblity to stage multiple issues and bulk push them was useful. 
This enables us to keep an overview and it assured creation of good descriptions and to think through what the issue would required for completion.
A task could have multiple attriubutes for weiging through priority, difficulty and effect. 
By having this 3rd party software, we where able to systematicly and visualy structre the project through agile development principles.


\section{github}

Implementing continuous integration (CI) with GitHub Actions and tox streamlined the project testing across multiple environments.
The benefits with continuous integration is all about catching regressions early through automated linting, unit tests, and cross-version compatibility checks. 
This setup ensures reliability before merging pull requests. 

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{Figures/CI.png}
    \caption{Implementation of contionous integration in github actions}
\end{figure}

As demonstrated, having implemented continous integration early on, 
gave significant help throughout the project, assuring working code before merging.


\chapter{Results}



% Bibliography
\blankpage\printbibliography

\end{document}